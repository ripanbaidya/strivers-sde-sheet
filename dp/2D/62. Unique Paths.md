# [62. Unique Paths](https://leetcode.com/problems/unique-paths/description/)

| Difficulty | Topic               | Companies | Resources   |
| ---------- | ------------------- | --------- | ----------- |
| **Medium** | Dynamic Programming | Google    | [Video](https://youtu.be/sdE0A2Oxofw)   |
|            |                     | Microsoft | [Article](https://takeuforward.org/data-structure/grid-unique-paths-dp-on-grids-dp8/) |

## Description
There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.

Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.

The test cases are generated so that the answer will be less than or equal to 2 * 109.

**Example 1**

![](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)

```
Input: m = 3, n = 7
Output: 28
```

**Example 2**
```
Input: m = 3, n = 2
Output: 3
Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
1. Right -> Down -> Down
2. Down -> Down -> Right
3. Down -> Right -> Down
```

**Constraints:**

- `1 <= m, n <= 100`


## Using Recursion â€“ O(2^(n+m)) Time and O(n+m) Space  
 
### Code
```java
class Solution {
    /**
     * Recursive function to calculate the number of unique paths from a cell at (row, col) 
     * to the bottom-right corner of an m x n grid.
     */
    public int count(int row, int col){
        // Base case 1: if we are at the starting cell (0, 0), there is only one path (the empty path).
        if(row == 0 && col == 0) 
            return 1;

        // Base case 2: if we are out of bounds, there are no paths.
        if(row < 0 || col < 0)
            return 0;

        // Recursive case: move either left or top and count the number of paths from the new cell.
        int left = count(row, col-1);
        int top = count(row-1, col);

        return left + top;
    }

    
    public int uniquePaths(int m, int n) {
        return count(m-1, n-1);
    }
}
```

### Complexity Analysis

- **Time Complexiy** : `O(2^(m+n))`
  - Each cell can branch into two recursive calls (move right or down), leading to exponential growth.
  
- **Space Complexity** : `O(m+n)`
  - The maximum depth of the recursion stack is m + n (the longest path from top-left to bottom-right).


## Using Top-Down DP (Memoization) - O(m*n) Time and O(m*n) Space  
 
### Code
```java
class Solution {
    /**
     * Recursive function to calculate the number of unique paths from a cell at (row, col) 
     * to the bottom-right corner of an m x n grid.
     */
    public int count(int row, int col, int[][] dp){
        // base case 1: if we are at the starting cell (0, 0), there is only one path (the empty path).
        if(row == 0 && col == 0) 
            return 1;
            
        // base case 2: if we are out of bounds, there are no paths.
        if(row < 0 || col < 0)
            return 0;

        // If the subproblem has already been solved, return the cached result.
        if(dp[row][col] != -1)
            return dp[row][col];

        // Recursive case: move either left or top and count the number of paths from the new cell.
        int left = count(row, col-1, dp);
        int top = count(row-1, col, dp);

        // Cache the result before returning it.
        return dp[row][col] = left + top;
    }
    
    /**
     * Compute the number of unique paths from the top-left corner of an m x n grid to the bottom-right corner.
     * Uses top-down dynamic programming (memoization) to optimize the computation.
     */
    public int uniquePaths(int m, int n) {
        // Create a DP table to cache intermediate results.
        int[][] dp = new int[m][n];
        Arrays.stream(dp).forEach(row -> Arrays.fill(row, -1));

        // Call the recursive function to compute the result.
        return count(m-1, n-1, dp);
    }
}
```

### Complexity Analysis

- **Time Complexiy** : `O(m*n)`
  - Each state (row, col) is computed only once and stored in the DP table.

- **Space Complexity** : `O(m*n)`
  - For the DP table plus recursion stack (which is at most O(m+n) but dominated by the DP table).