# [64. Minimum Path Sum](https://leetcode.com/problems/minimum-path-sum/description/)

| Difficulty | Topic               | Companies | Resources   |
| ---------- | ------------------- | --------- | ----------- |
| **Medium** | Dynamic Programming |           | [Video]()   |
|            |                     |           | [Article]() |

## Description
Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.

Note: You can only move either down or right at any point in time.

**Example 1**

![](https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg)

```
Input: grid = [[1,3,1],[1,5,1],[4,2,1]]
Output: 7
Explanation: Because the path 1 → 3 → 1 → 1 → 1 minimizes the sum.
```

**Example 2**
```
Input: grid = [[1,2,3],[4,5,6]]
Output: 12
```

**Constraints:**

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 200`
- `0 <= grid[i][j] <= 200`

## Using Recursion – O(2^(n+m)) Time and O(n+m) Space 
 
### Code
```java
class Solution {
    // this is the helper function computer the minimum path sum
    // @param sr=starting row, sc=starting column
    // @paran m = rows, n = columns
    // @param grid = grid array
    public int compute(int sr, int sc, int m, int n, int[][] grid){
        // base case 1. destination found
        if(sr == m-1 && sc == n-1)
            return grid[sr][sc];

        // base case 2. out of bounds
        // here, make sure not return 0, that might affect the final result.
        if(sr >= m || sc >= n)
            return Integer.MAX_VALUE;

        // right and down moves are allowed
        int right = grid[sr][sc] + compute(sr, sc+1, m, n, grid);
        int down = grid[sr][sc] + compute(sr+1, sc, m, n, grid);

        return Math.min(right, down);
    }
    public int minPathSum(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;

        return compute(0, 0, m, n, grid);
    }
}
```

### Complexity Analysis

- **Time Complexiy** : `O(n)`
- **Space Complexity** : `O(n)`


## Using Top-Down DP (Memoization) - O(m * n) Time and O(m * n) Space 
 
### Code
```java
class Solution {
    // this is the helper function computer the minimum path sum
    // @param sr=starting row, sc=starting column
    // @paran m = rows, n = columns
    // @param grid = grid array
    public int compute(int sr, int sc, int m, int n, int[][] grid, int[][] dp){
        // base case 1. destination found
        if(sr == m-1 && sc == n-1)
            return grid[sr][sc];

        // base case 2. out of bounds
        // here, make sure not return 0, that might affect the final result.
        if(sr >= m || sc >= n)
            return Integer.MAX_VALUE;

        // If the subproblem has already been solved, return the cached result.
        if(dp[sr][sc] != -1)
            return dp[sr][sc];

        // right and down moves are allowed
        int right = compute(sr, sc+1, m, n, grid, dp);
        int down = compute(sr+1, sc, m, n, grid, dp);

        // safely calculate min path sum, avoiding overflow
        int minNext = Math.min(right, down);
        dp[sr][sc] = (minNext == Integer.MAX_VALUE) ? Integer.MAX_VALUE : grid[sr][sc] + minNext;

        return dp[sr][sc]; 
    }
    public int minPathSum(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;

        int[][] dp = new int[m][n];
        Arrays.stream(dp).forEach(row -> Arrays.fill(row, -1));

        return compute(0, 0, m, n, grid, dp);
    }
}
```

### Complexity Analysis

- **Time Complexiy** : `O(m * n)`
- **Space Complexity** : `O(m * n) + O(n)`